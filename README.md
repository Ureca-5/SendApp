# 대용량 통신 요금 명세서 및 알림 발송 시스템

---
# Diagram
## 배치 시퀀스 다이어그램
<img width="7820" height="5240" alt="Image" src="https://github.com/user-attachments/assets/838185f3-6cbf-456d-8800-14247901d706" />

# 질문 리스트
## 배치
> 대규모 정산 배치를 실무에서는 어떤 단위와 방식으로 처리하는지에 대한 질문
1. **[정산 시점]** 실무 정산 시 **월 마감처럼 특정 시점에 일괄 배치로 처리**하는지, 아니면 서비스 중에도 분산 처리(스트리밍/마이크로배치)로 누적해가는지 궁금합니다.
2. **[배치 선점]** 다중 서버 환경에서 **배치 대상 선점**을 실무에서 보통 어떻게 처리하나요? 저희는 현재 ‘청구서가 생성되어 있지 않고, 당월에 정산해야 할 원천 데이터가 있는 회원’을 1,000명 단위로 선정해 정산하고 있는데, 서버 확장 시 동일 집단을 여러 대의 서버가 동시에 정산하는 문제가 발생할 수 있다고 보고 있습니다.
3. **[청크 기준]** 현업에서는 정산 배치의 **청크 기준**을 ‘회원 단위’와 ‘원천 데이터 단위’ 중 어떤 기준으로 잡는 경우가 많은지, 그리고 그 판단 기준은 무엇인지 궁금합니다.
4. **[청구서 정보 저장 방식]** 청구서 헤더와 상세 정보를 분리해 저장하는 구조에서, 정산에 성공한 모든 대상에 대해 헤더를 먼저 일괄 insert하고 생성된 헤더의 PK를 사용해 상세 정보를 일괄 insert 한 뒤, 실패 건은 별도 로그로 관리하는 방식이 일반적으로 사용되는 방식인지 궁금합니다.

## 발송
> 청구서 발송의 시작 시점, 트리거 방식, 대량 발송 제어에 대한 실무 관행 질문
1. **[발송 시작 시점]** 통신사 실무에서 청구서 발송은 보통 정산/청구서 생성 배치가 전체 완료된 이후에 일괄 시작하는지, 아니면 고객 또는 청구서 단위로 chunk가 완료될 때마다 발송 파이프라인에 투입하는 방식이 더 일반적인지 궁금합니다.
2. **[발송 트리거]** 시작 트리거는 InvoiceFinalized와 같은 사실 이벤트(Fact) 기반으로 처리하는 경우가 많은지, 아니면 운영자가 “발송 시작” 버튼을 누르는 수동 트리거 기반이 더 흔한지 궁금합니다. 
3. **[대량 발송 제어]** 발송 환경에서 발송 제어는 보통 큐(Redis/Kafka) 기반 워커 처리와 재시도 구조로 운영되는지, 그리고 금지 시간대(quiet hours) 정책은 큐에서 지연/보류 후 재개하는 방식과 별도의 예약 테이블을 두고 스케줄러가 제어하는 방식 중 어떤 접근이 실무에서 더 일반적인지 궁금합니다. 
4. **[최종 실패 처리]** 발송이 최종 실패했을 때 SMS로 대체 발송하는 정책은 실무에서도 흔한 패턴인지, 그리고 이때 “최종 실패” 판단 기준은 재시도 횟수 기준인지 에러 유형(영구 실패/일시 실패) 기준인지 궁금합니다.

## 협업
1. **[역할 분담]** 현업에서는 하나의 기능을 여러 개발자가 함께 개발할 때 보통 요청 생성/큐 적재 ↔ 워커 처리/외부 연동 같은 흐름 기준으로 역할을 나누는지, 아니면 Controller/Service/DB 같은 레이어 기준으로 나누는 경우가 많은지 궁금합니다.
2. **[사전 합의 요소]** 개발을 위해 실무에서는 보통 DB 스키마, 상태 값 및 상태 전이, API 또는 메시지 payload 형식 중 어떤 요소를 가장 먼저 합의하는 것이 일반적인지 궁금합니다. 
3. **[충돌 최소화]** 개발할 때 충돌을 줄이기 위해 인터페이스(메서드/DTO)를 먼저 정의한 뒤 각자 구현하거나 mock/stub로 먼저 연결을 확인하는 방식이 실제 현업에서도 많이 사용되는지 궁금합니다. 
4. **[공통 영역 관리]** enum, 공통 DTO처럼 충돌이 잦은 공통 영역은 실무에서 담당 오너를 정해 관리하는 방식과 문서/규칙을 먼저 합의한 뒤 반영하는 방식 중 어떤 접근이 더 안정적인지 궁금합니다.

## 보안
1. **[개인정보 보호]** 이메일, 전화번호 정보를 양방향 암호화하여 DB에 저장하고 로그나 api 응답 시에는 복호화 후 일부를 마스킹하는 방식을 채택하고자 합니다. 실무에서는 개인정보를 어떻게 보호하나요?

# Info

## 1. 기술 스택 (Tech Stack)

| 분류 | 기술 스택             |
| :--- |:------------------|
| **Language** | Java 17           |
| **Framework** | Spring Boot 3.5.9 |
| **Database** | MySQL 8           |
| **ORM/Mapper** | MyBatis           |
| **Migration** | Flyway            |
| **Build Tool** | Gradle            |
| **Frontend** | Thymeleaf         |

---

## 2. 협업 규칙 (Collaboration Rules)

### 개발 환경
- **Version Control:** GitHub
- **Communication:** Slack, Discord
- **IDE:** STS, IntelliJ

*제공되는 .env 파일을 src/main/resources 경로에 배치시켜주세요. 해당 파일은 절대 Github에 올리지 말아주세요.*

### 브랜치 전략
> 브랜치는 기능별(이슈 1개)로 생성하며, 작업 완료 후 PR(Pull Request)을 통해 머지합니다.

#### 브랜치 네이밍 규칙
- **형식:** type/{issueId}-{short-desc}
- **규칙:** 소문자 사용, 단어 사이 하이픈(-) 연결
- **issueId:** GitHub Issue 식별자 (없을 경우 YYYYMMDD-01 형식 허용)

| Type | 설명 | 예시 |
| :--- | :--- | :--- |
| **feat** | 새로운 기능 추가 | feat/12-admin-login |
| **fix** | 버그 수정 | fix/33-null-pointer |
| **docs** | 문서 수정 | docs/04-update-readme |
| **chore** | 설정 및 의존성 수정 | chore/05-add-flyway |

#### 브랜치 생성 및 머지 흐름
- 모든 작업 브랜치는 **dev** 브랜치에서 분기합니다.
- **분기:** git checkout -b feat/... origin/dev
- **PR 대상:** 모든 PR은 항상 dev 브랜치를 타겟으로 생성합니다.

---

### 커밋 메시지 컨벤션 (Commit Convention)

#### 메시지 형식
```
<type>(<scope>): <subject>
```

#### Type 목록
- feat: 기능 추가
- fix: 버그 수정
- refactor: 리팩터링
- docs: 문서 수정
- test: 테스트 코드 추가/수정
- chore: 설정, 빌드, 의존성 등 기타 작업
- perf: 성능 개선

#### Scope 및 Subject 규칙
- **Scope 예시:** auth, user, admin, notice, order, config, db, ci
- **Subject:** 현재형 작성, 마침표(.) 금지, 50자 이내 작성

> **커밋 예시**
> - feat(admin): 관리자 로그인 API 추가
> - fix(order): 주문 조회 시 NPE 수정
> - chore(db): flyway V2601101602__example.sql 추가

---

### 개발 규칙
- **커밋 크기:** 커밋 1개는 설명 가능한 단일 변경 단위로 작성합니다.
- **Flyway 관리:** DB 스키마 충돌 방지를 위해 Flyway 마이그레이션 파일 추가는 별도 커밋으로 분리를 권장합니다.
  - [Flyway 가이드(Notion)](https://www.notion.so/Flyway-2e1b40db26dd808a9633e76420c94b07)


**Flyway .sql 파일명 규칙**

*‘첫 버전’ 파일명은 예외적으로 **V1__init.sql**로 지정합니다.*
```
V[타임스탬프10자리 숫자]__[설명].sql # yymmddhhmm

# 25년11월25일 16시23분에 생성한 파일
ex) V2511251623__brewery_update_column_start_time.sql

# 25년11월25일 17시20분에 생성한 파일
ex) V2511251720__brewery_add_constraint_start_time.sql
```